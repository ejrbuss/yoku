--- mode Repl ---

--- test "Simple Enum" ---
enum Alignment {
	Good,
	Neutral,
	Evil
}

const a: Alignment = Alignment.Good
a --> Alignment.Good

const b = Alignment.Evil
b --> Alignment.Evil

a == Alignment.Good --> true
a === Alignment.Good --> true
b === Alignment.Evil --> true
b === Alignment.Evil --> true
a != b --> true
a !== b --> true

--- test "Matching Enum" ---
enum Parity { Even, Odd }

const _: Int = match Parity.Even {
	Parity.Even => { 0 }
} --> ! TypeError

const a: Int =  match Parity.Odd {
	Parity.Even => { 0 }
	Parity.Odd => { 1 }
}
a --> 1

const b: Int =  match Parity.Even {
	Parity.Even => { 2 }
	else => { 4 }
}
b --> 2

--- test "Tuple Enum" ---
enum TupleEnum {
	None,
	Zero(),
	One(Int)
	Two(Bool, Int)
}

var a: TupleEnum = TupleEnum.None
a = TupleEnum.None() --> ! TypeError
a = TupleEnum.Zero --> ! TypeError

a == TupleEnum.None --> true
a == TupleEnum.Zero() --> false
a == TupleEnum.One(1) --> false
a == TupleEnum.Two(false, -7) --> false

a = TupleEnum.One(4)
a == TupleEnum.One(4) --> true
a == TupleEnum.Two(true, 4) --> false

var assert TupleEnum.Two(b, c) = TupleEnum.Two(false, -1)
b --> false
c --> -1

proc match_tuple(t: TupleEnum) -> Str {
	match t {
		TupleEnum.None => { "None" }
		TupleEnum.Zero => { "Zero" }
		TupleEnum.One(x) => { cat("One", x) }
		TupleEnum.Two(x, y) => { cat(x, y) }
	}
}

match_tuple(TupleEnum.None) --> "None"
match_tuple(TupleEnum.Zero()) --> "Zero"
match_tuple(TupleEnum.One(4)) --> "One4"
match_tuple(TupleEnum.Two(true, 44)) --> "true44"


--- test "Struct Enum" ---