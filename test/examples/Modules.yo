--- mode Repl ---

--- test "Modules" ---

module M {
	const x = 1
	proc f() -> Int { 2 }
	proc g(n: Int) -> Int { n + 1 }
	struct S { var a: Int } 
	enum E { C, T(Int), S { var f: Int } }
}

M.x --> 1
M.f() --> 2
M.g(2) --> 3
const s: M.S = M.S { a = 4 }
s --> M.S { a = 4 }

proc m(x: M.E) -> Int {
	match x {
		M.E.C => { 1 }
		M.E.T(y) => { y }
		M.E.S { f = z } => { z }
	}
}

m(M.E.C) --> 1
m(M.E.T(2)) --> 2
m(M.E.S { f = 3 }) --> 3

--- test "Impl Modules" ---

impl Int {
	const x = 1
	proc f() -> Int { 2 }
	proc g(n: Int) -> Int { n + 1 }
}

Int.x --> 1
Int.f() --> 2
Int.g(2) --> 3

--- test "Methods" ---

impl Int {
	const x = 1
	proc f() -> Int { 2 }
	proc g(n: Int) -> Int { n + 1 }
	proc h(n: Int, m: Int) -> Int { n * m }
}

const x = 3
x.g() --> 4
(4).g() --> 5
x.h(5) --> 15
(6).h(7) --> 42

--- test "Methods on User Defined Types" ---

struct A {}
struct B {}

impl A {
	proc f(a: A) -> Int { 1 }
}

impl B {
	proc f(b: B, n: Int) -> Int { 2 + n }
}

const a = A {}
a.f() --> 1
const b = B{}
b.f(2) --> 4

--- skip "This Type" ---

impl Int {
	proc f(x: This) -> This { x + 1 }
}

Int.f(2) --> 3
(3).f() --> 4

--- skip "Methods on Anonymous Types" ---

impl (Int, Int) {
	proc sum((x, y): (Int, Int)) -> { x + y }
	proc product(p: This) -> { p.0 * p.y }
}

(3, 4).sum() --> 7
(5, 6).product() --> 30

--- skip "Lazy Proc Declaraction Order" ---

module M {

	proc one() -> Int {
		return two() - 1
	}

	proc two() -> Int {
		2
	}

}

M.one() --> 1
M.two() --> 2

--- skip "Module Redeclarations" ---

Int.x --> ! TypeError
x.g() --> ! TypeError